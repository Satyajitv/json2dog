#!/usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use LWP::Simple qw(get);
use JSON;

use DataDog::DogStatsd;

# options
my $debug = 0; #TODO: handle options
my $delay = 60; # seconds

# read command line arguments
my ($health_url,$statsd_base) = @ARGV;

# defaults
unless (defined $health_url) {
	$health_url = 'https://jsonplaceholder.typicode.com/posts/1';
}
print "checking $health_url\n";

unless (defined $statsd_base) {
	$statsd_base = 'test.json';
	warn "defaulting stats_base to '$statsd_base'.";
}

# instances of handy objects
my $dogstatsd = DataDog::DogStatsd->new;
my $json = JSON->new->allow_nonref;

# keep pulling stats until we get killed
while (1) {
	my $raw_html = get($health_url);
	#print "$raw_html\n";

	unless (defined $raw_html and length $raw_html) {
		die "no data back from $health_url";
	}

	my $health_resp = $json->decode($raw_html);
	print Dumper($health_resp) if $debug;

	foreach my $key (keys %$health_resp) {
		my $value = $health_resp->{$key};
		if ($value =~ /^[0-9.]+$/) { # only numbers
			my $metric_label = $statsd_base . '.' . $key;
			print "$metric_label -> $value\n";
			if ($debug) {
				print "skipped sending metric $metric_label($value)";
			} else {
				$dogstatsd->gauge( $metric_label, $value);
			}
		}
	}

	print "\n";
	sleep($delay-1); # TODO: more elegant calculation of how long it took to do one iteration
}

sub curl {
	my ($url) = @_;
	my $output = `curl -s $url`;
	return $output;
}
